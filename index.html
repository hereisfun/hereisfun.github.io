<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Fung的肠粉店</title>
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/header.png)">
        <div class='av-pic' style="background-image: url(/assets/tree_small.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Fung的肠粉店</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2017/05/15/异步编程的异常处理/">test</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2017-05-15T04:44:29.000Z" itemprop="datePublished">
    2017-05-15
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/前端/">前端</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <blockquote>
<p>本文主要参考自 @黄子毅 的 <a href="http://www.jianshu.com/p/78dfb38ac3d7" target="_blank" rel="external">Callback Promise Generator Async-Await 和异常处理的演进</a>, 对内容进行了一定的加工整理，并修改了原文中的一些错误。</p>
</blockquote>
<p>#回调<br>1.无法捕获的异常<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'请求失败'</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    fetch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'请求处理'</span>) <span class="comment">// 永远不会执行</span></div><div class="line">    &#125;)</div><div class="line">&#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'触发异常'</span>, error) <span class="comment">// 永远不会执行</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 程序崩溃</span></div><div class="line"><span class="comment">// Uncaught Error: 请求失败</span></div></pre></td></tr></table></figure></p>
<p>执行回调时已经不是出于原本的执行栈了，Error发生在下一轮事件循环中，所以没有被<code>try...catch</code>捕获</p>
<p>2.<code>Error-First</code>约定<br>对于高度依赖异步回调的Node.js，采用了Error-First的约定，即：</p>
<blockquote>
<ol>
<li>callback的第一个参数必须是一个error对象，如果没有出错则该值为null</li>
<li>第二个参数为异步操作成功后的结果</li>
</ol>
</blockquote>
<p>好处在于，进行异步函数出错时，它不需要知道如何处理Error，也不会直接让程序崩溃。而是把错误交给你，让你自行选择<strong>忽略</strong>、<strong>处理</strong>或者<strong>冒泡给别的callback</strong>。</p>
<p>#Promise<br><em>前置知识：promise内部的错误不会冒泡到全局</em><br>1.reject的Error都能捕获（实质为microtask中抛出的异常）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以下异常都能被捕获</span></div><div class="line"><span class="keyword">var</span> prom = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'noo'</span>); <span class="comment">// 直接throw Error可捕获（因为在microtask中）</span></div><div class="line"><span class="comment">//   reject('nooo'); // reject当然也可以</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">prom</div><div class="line">  .then(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'working'</span>,err)) <span class="comment">// 不运行</span></div><div class="line">  .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e)); <span class="comment">//运行</span></div><div class="line">  </div><div class="line"><span class="comment">//又如</span></div><div class="line"><span class="keyword">var</span> prom = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</div><div class="line">  resolve(<span class="string">'resolved'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">prom</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'nooo'</span>);<span class="comment">//也是在microtask中抛出，可捕获</span></div><div class="line">    <span class="comment">// return Promise.reject('nooo') // 返回一个rejected的promise也能捕获</span></div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'working'</span>,err))<span class="comment">// 不运行</span></div><div class="line">  .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e));<span class="comment">// 运行</span></div></pre></td></tr></table></figure></p>
<p>注意链式调用中，能传递的错误只有在microtask中<code>throw Error</code>以及<code>return</code> rejected的promise，其它返回值均包装成resolve的promise，包括Error:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prom = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</div><div class="line">  resolve(<span class="string">'resolved'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">prom</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Error</span>(<span class="string">'nooo'</span>) <span class="comment">// 不视作异常, 返回一个Error对象</span></div><div class="line">    <span class="comment">//Promise.reject('nooo') // 不视作异常，因为返回值为undefined</span></div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'working'</span>,err)) <span class="comment">// 运行</span></div><div class="line">  .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e)); <span class="comment">// 不运行</span></div></pre></td></tr></table></figure></p>
<p>2.macrotask中抛出的异常无法捕获<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prom = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'nooo'</span>); </div><div class="line">  &#125;,<span class="number">0</span>)</div><div class="line">  </div><div class="line">&#125;)</div><div class="line"></div><div class="line">prom</div><div class="line">  .then(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'working'</span>,err))</div><div class="line">  .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e));</div><div class="line"><span class="comment">//程序崩溃</span></div></pre></td></tr></table></figure></p>
<p>其实很好理解，setTimeout中的回调是进入macrotask的，即进入新一轮事件循环，此时上下文环境已改变，即相当于单独使用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() =&gt; &#123;<span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'nooo'</span>);</div></pre></td></tr></table></figure></p>
<p>另外prom实质上处于pending状态，自然也无法进入then的链式调用。</p>
<p>解决方案也很简单，可以使用try…catch捕获错误，然后传递给reject。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prom = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'nooo'</span>);</div><div class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">      reject(e) <span class="comment">// 捕获异常，并传递给catch</span></div><div class="line">    &#125;</div><div class="line">  &#125;,<span class="number">0</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">prom</div><div class="line">  .then(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'working'</span>,err))</div><div class="line">  .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e));</div></pre></td></tr></table></figure></p>
<p>当然，一个很常见的场景就是使用第三方函数，然后第三方函数在macrotask中抛出了错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thirdFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'就是任性'</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.resolve(<span class="literal">true</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    thirdFunction()</div><div class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获异常'</span>, error)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 程序崩溃</span></div><div class="line"><span class="comment">// Uncaught Error: 就是任性</span></div></pre></td></tr></table></figure></p>
<p>很遗憾，只能让其改为promise并进行reject（可见promise是未来大势所趋）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thirdFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            reject(<span class="string">'收敛一些'</span>)</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.resolve(<span class="literal">true</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 注意这里的return，缺少return会怎样？请认真阅读前文</span></div><div class="line">    <span class="comment">// 然而此处的return极其容易忘记，更优雅的方案见后文async</span></div><div class="line">    <span class="keyword">return</span> thirdFunction()</div><div class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获异常'</span>, error) <span class="comment">// 捕获异常 收敛一些</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>3.利用macrotask抛出的异常<br>尽管最后又<code>.catch()</code>捕获错误，但万一<code>.catch()</code>内部抛出错误，该错误就无法被捕捉到了（promise内部的错误不会冒泡到全局）<br>这时利用macrotask抛出的异常能冒泡到全局这一特性,实现<code>.done()</code>方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> err&#125;, <span class="number">0</span>)</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//用法</span></div><div class="line">asyncFunc()</div><div class="line">  .then(f1)</div><div class="line">  .catch(r1)</div><div class="line">  .then(f2)</div><div class="line">  .done();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Promise异常处理小结：</p>
<ol>
<li>macrotask中抛出的错误（<code>throw Error(&#39;msg&#39;)</code>）无法捕获，需通过promise的reject来传递错误</li>
<li>microtask中的错误，直接<code>throw Error(&#39;msg&#39;)</code>和<code>return</code>reject的promise都能传递</li>
<li><code>then</code>中除了<code>return</code>reject的promise，其它返回值都会被包装成resolve的promise</li>
</ol>
</blockquote>
<p>#Async函数<br>async函数就是自动运行的状态机，而状态机（Generator）又提供切出切入（并保留上下文）的功能（有没有想起前文因上下文丢失而无法处理的Error？）</p>
<p>##Async的异常<br>await不会自动捕获异常，但会中断async函数的进行，而不是直接让程序崩溃。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        reject()</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> fetch() <span class="comment">// rejected的promise被传入</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'请求处理'</span>, result) <span class="comment">// 不会执行，async函数终止</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">main()</div></pre></td></tr></table></figure></p>
<p>##Async捕获异常<br>Async函数能通过使用<code>try...catch</code>捕获异常（当然在macrotask中抛出的异常仍旧无法捕获，原因同promise）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thirdFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            reject(<span class="string">'收敛一些'</span>)</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">const</span> result1 = <span class="keyword">await</span> secondFunction() <span class="comment">// 如果不抛出异常，后续继续执行</span></div><div class="line">        <span class="keyword">const</span> result2 = <span class="keyword">await</span> thirdFunction() <span class="comment">// 抛出异常</span></div><div class="line">        <span class="keyword">const</span> result3 = <span class="keyword">await</span> thirdFunction() <span class="comment">// 永远不会执行</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'请求处理'</span>, result) <span class="comment">// 永远不会执行</span></div><div class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'异常'</span>, error) <span class="comment">// 异常 收敛一些</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">main()</div></pre></td></tr></table></figure></p>
<p>值得注意的是，async返回的是一个promise对象，所以也可以通过对Async返回的promise对象进行异常捕获：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thirdFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            reject(<span class="string">'收敛一些'</span>)</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="literal">true</span>) <span class="comment">// 如果不抛出异常，后续继续执行</span></div><div class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> thirdFunction() <span class="comment">// 抛出异常</span></div><div class="line">    <span class="keyword">const</span> result3 = <span class="keyword">await</span> thirdFunction() <span class="comment">// 永远不会执行</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'请求处理'</span>, result1) <span class="comment">// 永远不会执行</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">main()</div><div class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'异常'</span>,err)); <span class="comment">// 异常 收敛一点</span></div></pre></td></tr></table></figure></p>
<p>##模仿async<br>async/await不在ES6标准中，但其实我们也可以对generator进行包装，让其自动运行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoRun</span>(<span class="params">generator</span>) </span>&#123;</div><div class="line">  <span class="comment">//首先async返回的是一个promise</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> gen = generator();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nextThrow</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">      <span class="comment">// 当上一个yielded的value是rejection时</span></div><div class="line">      <span class="comment">// 尝试向generator内部抛出错误</span></div><div class="line">      <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">var</span> next = func();</div><div class="line">      &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">        <span class="comment">// 如果generator内部没有try...catch捕获错误，则会在此处捕获</span></div><div class="line">        <span class="comment">// 并让autoRun返回一个rejection，与async行为一致</span></div><div class="line">        reject(e)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(next.done)&#123;</div><div class="line">        resolve(next.value);</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">// 保证rejection和非promise值能被处理</span></div><div class="line">        <span class="built_in">Promise</span>.resolve(next.value).then(</div><div class="line">          <span class="function">(<span class="params">result</span>) =&gt;</span> nextThrow(<span class="function"><span class="params">()</span> =&gt;</span> gen.next(result)),</div><div class="line">          (rejection) =&gt; nextThrow(<span class="function"><span class="params">()</span> =&gt;</span> gen.throw(rejection))<span class="comment">// 值为rejection时向generator内部抛出错误，在下一轮才执行是为了方便捕获</span></div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//启动</span></div><div class="line">    nextThrow(<span class="function"><span class="params">()</span> =&gt;</span> gen.next());</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;...&#125;</div><div class="line"><span class="keyword">var</span> resultProm = autoRun(gen);</div><div class="line">result.then(...)</div><div class="line">        .catch(...)<span class="comment">//能像async一样使用</span></div></pre></td></tr></table></figure></p>
<p>#冒泡处理异常<br>考虑一下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> successRequest = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">'a'</span>)</div><div class="line"><span class="keyword">const</span> failRequest = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.reject(<span class="string">'b'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</div><div class="line">    <span class="keyword">async</span> successReuqest() &#123;</div><div class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> successRequest()</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'successReuqest'</span>, <span class="string">'处理返回值'</span>, result) <span class="comment">// successReuqest 处理返回值 a</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">async</span> failReuqest() &#123;</div><div class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> failRequest()</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'failReuqest'</span>, <span class="string">'处理返回值'</span>, result) <span class="comment">// 永远不会执行</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">async</span> allReuqest() &#123;</div><div class="line">        <span class="keyword">const</span> result1 = <span class="keyword">await</span> successRequest()</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'allReuqest'</span>, <span class="string">'处理返回值 success'</span>, result1) <span class="comment">// allReuqest 处理返回值 success a</span></div><div class="line">        <span class="keyword">const</span> result2 = <span class="keyword">await</span> failRequest()</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'allReuqest'</span>, <span class="string">'处理返回值 success'</span>, result2) <span class="comment">// 永远不会执行</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> action = <span class="keyword">new</span> Action()</div><div class="line">action.successReuqest()</div><div class="line">action.failReuqest()</div><div class="line">action.allReuqest()</div></pre></td></tr></table></figure></p>
<p>程序不会崩溃，因为promise内部的异常不冒泡到全局（即使throw Error也是，但如果macrotask上throw Error即使try…catch也无法捕获）</p>
<p>为了捕获异常，需要给每个async都包裹一层<code>try...catch</code>或者给async的返回结果加上<code>.catch()</code>，难免显得有点繁琐。于是我们的解决方案登场了：</p>
<p>##Decorator（修饰器）<br>这是ES7的一个提案，目前Babel已通过插件支持。<br>简单来说就是修饰器能在代码编译阶段改变类的行为。<br>下面是一个简单的类修饰器示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</div><div class="line">  target.isTestable = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@testable</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(MyTestableClass.isTestable) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>类修饰器接受一个参数<code>target</code>，为类的构造函数。现在，我们想给类中每一个async函数都包裹一层<code>try...catch</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//我们先对类装饰器进行柯里化，传入一个errorHandler作参数</span></div><div class="line"><span class="keyword">const</span> asyncErrorWrapper = <span class="function">(<span class="params">errorHandler</span>) =&gt;</span> (target) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> props = <span class="built_in">Object</span>.getOwnPropertyNames(target.prototype);</div><div class="line">    props.forEach(<span class="function">(<span class="params">prop</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">var</span> value = target.prototype[prop];</div><div class="line">        <span class="comment">// 判断如果是async函数则包裹try...catch</span></div><div class="line">        <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object AsyncFunction]'</span>)&#123;</div><div class="line">          target.prototype[prop] = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">            <span class="comment">// 注意千万不能漏掉await</span></div><div class="line">              <span class="keyword">await</span> value.apply(<span class="keyword">this</span>,args);</div><div class="line">            &#125;<span class="keyword">catch</span>(err)&#123;</div><div class="line">              errorHandler(err);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 生成一个errorHandler为console.log的装饰器</span></div><div class="line"><span class="keyword">const</span> logError = asyncErrorWrapper(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'异常'</span>,err));</div><div class="line"></div><div class="line"><span class="keyword">const</span> successRequest = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">'a'</span>)</div><div class="line"><span class="keyword">const</span> failRequest = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.reject(<span class="string">'b'</span>)</div><div class="line"></div><div class="line"><span class="comment">//应用装饰器</span></div><div class="line">@logError</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</div><div class="line">    <span class="keyword">async</span> successReuqest() &#123;</div><div class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> successRequest();</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'successReuqest'</span>, <span class="string">'处理返回值'</span>, result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">async</span> failReuqest() &#123;</div><div class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> failRequest();</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'failReuqest'</span>, <span class="string">'处理返回值'</span>, result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">async</span> allReuqest() &#123;</div><div class="line">        <span class="keyword">const</span> result1 = <span class="keyword">await</span> successRequest();</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'allReuqest'</span>, <span class="string">'处理返回值 success'</span>, result1);</div><div class="line">        <span class="keyword">const</span> result2 = <span class="keyword">await</span> failRequest();</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'allReuqest'</span>, <span class="string">'处理返回值 success'</span>, result2);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> action = <span class="keyword">new</span> Action();</div><div class="line">action.successReuqest()</div><div class="line">action.failReuqest()</div><div class="line">action.allReuqest()</div></pre></td></tr></table></figure></p>
<p>通过这样的统一处理，前端可以用alert兜底，node端也可以返回500兜底，避免程序崩溃的同时也掌握了处理异常的主动权。</p>
<p>#One more thing<br>别忘了可能还有漏网之鱼，我们可以通过监听全局错误来处理：<br>在<strong>浏览器</strong>端，监听未处理的rejection<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 仅chrome49支持</span></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"unhandledrejection"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.warn(<span class="string">"WARNING: Unhandled promise rejection. Shame on you! Reason: "</span>+ event.reason);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在<strong>Node.js</strong>端（v1.4.1已支持）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用Map记录没处理的rejection</span></div><div class="line"><span class="keyword">const</span> unhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">process.on(<span class="string">'unhandledRejection'</span>, (reason, p) =&gt; &#123;</div><div class="line">  unhandledRejections.set(p, reason);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 处理后从Map中删除记录</span></div><div class="line">process.on(<span class="string">'rejectionHandled'</span>, (p) =&gt; &#123;</div><div class="line">  unhandledRejections.delete(p);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2017/05/11/hello-world/">Hello World</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2017-05-11T08:38:50.044Z" itemprop="datePublished">
    2017-05-11
  </time>
  
  
</div>

    </header>
    <div>
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
</article>

    </li>
  
</ul>


            <footer>
    <div>© 2016 - fung </div>
    <div>
    Powered by Hexo
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>